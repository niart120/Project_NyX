# アーキテクチャ概要

本プロジェクトは、Nintendo Switch 向けの自動化支援ソフトウェアとして、PC 上で複数のハードウェア（キャプチャボード、シリアル通信デバイス）と連携し、ユーザー作成マクロを実行するフレームワークです。

このドキュメントでは本プロジェクトにおけるアーキテクチャの概要を示します。(generated by chatGPT o3-mini)

## ディレクトリ構成
```
├─src
│  │  config.py
│  │  main.py
│  │
│  ├─framework
│  │  │  __init__.py
│  │  │
│  │  └─core
│  │      │  __init__.py
│  │      │
│  │      ├─api
│  │      │      client.py
│  │      │      __init__.py
│  │      │
│  │      ├─exception
│  │      │      handler.py
│  │      │      __init__.py
│  │      │
│  │      ├─hardware
│  │      │      capture.py
│  │      │      protocol.py
│  │      │      serial_comm.py
│  │      │      __init__.py
│  │      │
│  │      ├─image_recognition
│  │      │      detector.py
│  │      │      __init__.py
│  │      │
│  │      ├─logger
│  │      │      log_manager.py
│  │      │      __init__.py
│  │      │
│  │      └─macro
│  │              base.py
│  │              command.py
│  │              constants.py
│  │              executor.py
│  │              __init__.py
│  │
│  ├─gui
│  │      controller.py
│  │      __init__.py
│  │
│  ├─macros
│  │      sample_macro.py
│  │      __init__.py
│  │
│  └─utils
│          helper.py
│          __init__.py
│
└─tests
        test_basic.py
        __init__.py

```

## 各層の責務

- **マクロフレームワーク層 (Macro):**  
  ユーザー作成マクロは `MacroBase` を継承して実装し、フレームワーク側はマクロのライフサイクル（initialize, run, finalize）を管理します。  
  高レベル操作は `Command` インターフェース経由で発行され、内部では待機制御（dur, wait）や操作発行のタイミングを管理します。

- **ハードウェア連携層 (Hardware):**  
  キャプチャデバイスとシリアル通信デバイスを管理し、実際のデータ取得および送信を担います。  
  複数デバイスの切替えや接続管理は、それぞれのマネージャー（CaptureManager, SerialManager）で行います。

- **通信プロトコル層 (Protocol):**  
  高レベル操作のパラメータを、シリアル通信に必要なバイナリ形式に変換します。  
  インターフェース `SerialProtocolInterface` による抽象化と、具体的な実装（DefaultSerialProtocol）で変換処理を行います。


## 各コンポーネントの詳細
### MacroBase (ユーザー側のマクロ定義)
- 責務:
  ユーザーが実装するマクロの骨格を定義する。
  マクロ内での操作はすべて、Command インターフェースを通じて発行される。

- 連携:
  フレームワーク側がマクロのライフサイクル（initialize, run, finalize）を管理する際、各フェーズに Command インスタンスを渡す。

## Command (高レベル操作の抽象化)
- 責務:
  マクロ実行中に、ユーザーの操作（ボタン押下、キーボード入力など）を高レベルのメソッド呼び出しとして提供する。
  具体的な DefaultCommand はこれを実装し、操作のタイミングや待機制御（dur, wait）を管理する。

- 連携:

  - SerialProtocol:
    DefaultCommand の内部で、各操作を通信プロトコルに基づいたコマンドデータに変換するために利用する。

  - SerialManager:
    生成されたコマンドデータを実際のシリアル通信で送信する際に、SerialManager 経由で送信する。

### SerialProtocol (通信プロトコルの抽象化)
- 責務:
  高レベル操作のパラメータ（例えば、キー情報、待機時間など）を、シリアル通信に必要なバイナリ形式に変換する。
  具体的なプロトコル仕様（ヘッダー、フッター、チェックサムなど）はここで扱う。
  抽象クラスまたはインターフェースとして定義し、将来的に複数のプロトコル実装をサポートできるようにする。

- 連携:

  - Command (DefaultCommand):
    Command 側は、操作に応じたコマンドデータを生成する際に SerialProtocol のメソッドを呼び出す。

  - SerialManager:
    変換されたコマンドデータは、SerialManager に送られ実際の通信が行われる。

### SerialManager (シリアル通信の実装とデバイス管理)
責務:
複数のシリアルデバイス（PCに接続されたデバイス）を管理し、現在利用するデバイスを動的に切り替える。
SerialComm の抽象インターフェースに基づいて、コマンドデータの送受信を行う。
SerialProtocol の生成物（コマンドデータ）を実際に送信する。

- 連携:

  - DefaultCommand:
    DefaultCommand は SerialManager を通じて、プロトコル変換後のコマンドデータを送信する。

  - SerialProtocol:
    SerialManager は、直接プロトコル変換は行わず、Command 側で作成されたデータを単に送信する役割を担う。

## 連携フローの概要
1. マクロ実行 (MacroBase)

ユーザー作成マクロは MacroBase を継承し、initialize(), run(), finalize() を実装。

フレームワーク側（例：MacroExecutor）がこれらのメソッドを順次呼び出す際、Command インターフェースのインスタンス（通常は DefaultCommand）を渡す。

2. 操作の発行 (Command)

例：マクロ内で cmd.press(Button.A, dur=0.2, wait=0.1) が呼ばれると、DefaultCommand が実行される。

DefaultCommand はまず、押下操作のコマンドデータを生成するため、SerialProtocol の build_press_command(keys) を呼び出す。

3. プロトコル変換 (SerialProtocol)

SerialProtocol は、渡されたキー情報や操作パラメータを受け、仕様に従ったバイナリデータを生成する。

この抽象化により、将来的にプロトコルが変更になっても DefaultCommand はそのインターフェースのみを利用すればよい。

4. 送信 (SerialManager)

DefaultCommand は生成されたコマンドデータを SerialManager に渡して送信する。

SerialManager は現在アクティブなシリアルデバイスへデータを送信する。また、デバイスの切り替えなども管理する。

5. 待機・リリース操作

DefaultCommand は、通信後に dur 秒待機し、次に同様に解放操作のコマンドデータを生成し、送信後 wait 秒待機する。

## 将来的な拡張

- **手動入力機能:**  
  PCに接続したコントローラーやキーボードからの手動入力層を追加する際、入力取得・イベント処理部分は専用モジュールで扱い、  
  既存の自動操作層（Command, SerialProtocolInterface, SerialManager）とは別のフローとして実装します。  
  共通の送信部分は共有し、モード切替や競合解消の仕組みで両者の連携を管理する予定です。

- **将来的な拡張性:**  
  マクロの中断機能、複数マクロの選択実行、詳細なエラーハンドリングなどは将来的な拡張項目として検討中です。
