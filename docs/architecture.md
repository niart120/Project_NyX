# アーキテクチャ設計仕様書

## 1. 概要

### 1.1 本書の目的
本書は、Nintendo Switch 向け自動化支援フレームワーク「Project NyX」の設計思想、全体アーキテクチャ、およびコンポーネント間の連携について説明するものです。開発者およびコントリビューターが本システムを理解し、適切な実装・拡張を行うための指針となります。(generated by Claude 3.7 Sonnet)

### 1.2 システム概要
本システムは、Nintendo Switch への入力自動化および画面認識を行うためのフレームワークです。PCに接続されたキャプチャデバイスからゲーム画面を取得し、シリアル通信デバイスを介してコントローラー操作を送信します。ユーザーはマクロ言語でゲーム操作を記述でき、フレームワークがその実行を管理します。

### 1.3 採用アーキテクチャ
責務分離・依存性注入・インターフェース抽象化を基本原則として採用し、複数のレイヤーに分離されています。これにより、各コンポーネントのテスト容易性と柔軟な拡張性を確保しています。

## 2. レイヤー構成

### 2.1 マクロフレームワーク層
ユーザー定義のマクロ実行とライフサイクル管理を担当します。

- ユーザーは `MacroBase` を継承してマクロを実装
- `MacroExecutor` がマクロのロードとライフサイクル管理を担当
- 高レベル操作は `Command` インターフェース経由で提供

### 2.2 ハードウェア連携層
複数のハードウェアデバイスの管理、切替、通信制御を担当します。

- `SerialManager` がシリアル通信デバイスを管理
- `CaptureManager` がキャプチャデバイスを管理
- Managerインスタンスはシングルトンとして一元管理され、DeviceModel経由で参照・切替される (GUI)

### 2.3 通信プロトコル層
高レベル操作命令をデバイス固有のバイナリプロトコルに変換します。

- `SerialProtocolInterface` による抽象化
- プロトコル実装（例: `CH552SerialProtocol`）は交換可能
- プロトコル仕様の詳細は別文書に記載

### 2.4 ユーティリティ層
ログ管理、リソース管理、例外処理などの共通機能を提供します。

- `LogManager` によるログの統一管理
- `StaticResourceIO` による画像等のリソース管理
- `CancellationToken` によるマクロ実行制御

## 3. コア・コンポーネント

### 3.1 マクロ定義とライフサイクル

#### 3.1.1 MacroBase
ユーザー定義マクロの基底クラスで、以下のメソッドを持ちます。

```python
class MacroBase(ABC):
    @abstractmethod
    def initialize(self, cmd: Command, args: dict) -> None:
        """マクロ実行前の初期化処理"""
        pass
    
    @abstractmethod
    def run(self, cmd: Command) -> None:
        """マクロのメイン処理"""
        pass
    
    @abstractmethod
    def finalize(self, cmd: Command) -> None:
        """マクロ実行後の後処理"""
        pass
```

#### 3.1.2 MacroExecutor
マクロのロード、選択、実行を管理するクラスです。

- `load_all_macros()`: `macros` ディレクトリから利用可能なマクロをロード
- `select_macro(macro_name)`: 指定マクロをアクティブに設定
- `execute(cmd, exec_args)`: マクロのライフサイクルを順次実行

例外発生時も `finalize()` が確実に呼ばれるよう設計されています。

### 3.2 コマンドインターフェース

#### 3.2.1 Command インターフェース
マクロからアクセスできる操作命令を定義する抽象インターフェースで、以下のメソッドを提供します。

- `press(*keys, dur, wait)`: キー押下、指定時間後に解放、その後待機
- `hold(*keys)`: キー押下（解放せず保持）
- `release(*keys)`: キー解放
- `wait(seconds)`: 指定秒数の待機
- `capture(crop_region, grayscale)`: 画面キャプチャ取得
- `save_img(filename, image)`: 画像保存
- `load_img(filename, grayscale)`: 画像読込
- `keyboard(text)`: キーボード入力
- `log(*values, level)`: ログ出力
- `stop()`: マクロ実行中断

#### 3.2.2 DefaultCommand
`Command` インターフェースの標準実装です。

- `serial_device`/`capture_device` を直接受け取り、各デバイス操作を実行
- `SerialProtocolInterface` を利用してコマンドのバイナリ変換
- タイミング制御（`dur`, `wait`）を担当

```python
class DefaultCommand(Command):
    def __init__(self, serial_device, capture_device, resource_io, protocol, ct):
        self.serial_device = serial_device
        self.capture_device = capture_device
        self.resource_io = resource_io
        self.protocol = protocol
        self.ct = ct
    def press(self, *keys, dur=0.1, wait=0.1):
        press_data = self.protocol.build_press_command(keys)
        self.serial_device.send(press_data)
        # ...
    def capture(self, ...):
        frame = self.capture_device.get_frame()
        # ...
```

### 3.3 ハードウェア管理

#### 3.3.1 DeviceModelとシングルトン設計
ハードウェア操作の依存性を一元管理するため、Managerインスタンスは`singletons.py`でグローバルに生成され、
DeviceModel経由で各Paneやコマンドに注入されます。(GUI)

- `DeviceModel`がアクティブなデバイスの切替・参照・イベント発行を担当
- 各GUIコンポーネントやコマンドはDeviceModel/Managerからデバイスを受け取って操作

#### 3.3.2 SerialManager
複数のシリアル通信デバイスを管理し、アクティブデバイスの切替を行います。

- `register_device(name, device)`: デバイス登録
- `set_active(name, baudrate)`: 指定デバイスをアクティブに設定
- `get_active_device()`: 現在アクティブなデバイスを取得
- `close_active()`: アクティブデバイスの接続を解放

#### 3.3.3 CaptureManager
複数のキャプチャデバイスを管理し、アクティブデバイスの切替を行います。

- `register_device(name, device)`: デバイス登録
- `set_active(name)`: 指定デバイスをアクティブに設定
- `get_active_device()`: 現在アクティブなデバイスを取得
- `release_active()`: アクティブデバイスのリソース解放

### 3.4 プロトコル変換

#### 3.4.1 SerialProtocolInterface
高レベル操作をバイナリプロトコルに変換するインターフェースです。

```python
class SerialProtocolInterface(ABC):
    @abstractmethod
    def build_press_command(self, keys: tuple[KeyType, ...]) -> bytes:
        """キー押下操作のコマンドデータを生成"""
        pass
    
    @abstractmethod
    def build_release_command(self, keys: tuple[KeyType, ...]) -> bytes:
        """キー解放操作のコマンドデータを生成"""
        pass
    
    @abstractmethod
    def build_keyboard_command(self, text: str) -> bytes:
        """キーボード入力操作のコマンドデータを生成"""
        pass
```

#### 3.4.2 CH552SerialProtocol
CH552デバイス向けの具体的なプロトコル実装です。
詳細仕様は `docs/protocol/ch552_protocol_spec.md` に記載されています。

## 4. 処理フロー

### 4.1 マクロ実行フロー

1. **マクロロード**:
   - `MacroExecutor` が起動時に `macros` ディレクトリからマクロをロード
   - `select_macro(name)` で実行対象マクロを設定

2. **初期化フェーズ**:
   - `executor.execute(cmd)` の呼び出しで `macro.initialize(cmd, args)` を実行
   - 引数情報をマクロに渡し、リソース確保や初期設定を実施

3. **実行フェーズ**:
   - `macro.run(cmd)` でマクロのメイン処理を実行
   - `cmd` のメソッド経由で各種操作を実行

4. **終了フェーズ**:
   - 正常終了・例外発生に関わらず `macro.finalize(cmd)` を実行
   - リソース解放やクリーンアップ処理を実施

### 4.2 操作実行フロー

1. **高レベル操作呼び出し**:
   ```python
   cmd.press(Button.A, dur=0.1, wait=0.05)
   ```

2. **コマンド変換処理**:
   - `DefaultCommand` が処理を受け付け
   - `SerialProtocolInterface` の実装を使用してバイナリデータを生成
   ```python
   press_data = self.protocol.build_press_command(keys)
   ```

3. **データ送信**:
   - `serial_device` に直接送信
   ```python
   self.serial_device.send(press_data)
   ```

4. **タイミング制御**:
   - `dur` 秒間待機後、解放操作を実行
   - さらに `wait` 秒間待機
   ```python
   time.sleep(dur)
   release_data = self.protocol.build_release_command(keys)
   self.serial_device.send(release_data)
   time.sleep(wait)
   ```

### 4.3 キャプチャ・画像処理フロー

1. **キャプチャ要求**:
   ```python
   image = cmd.capture(crop_region=(100, 100, 400, 300), grayscale=True)
   ```

2. **画像取得**:
   - `DefaultCommand` が `capture_device` から直接フレームを取得

3. **画像処理**:
   - リサイズ処理（HD解像度 1280x720 に統一）
   - 指定領域のクロップ処理
   - 必要に応じてグレースケール変換

4. **画像分析と操作**:
   - キャプチャした画像に対して認識処理や判断を実施
   - 結果に応じたコントローラー操作を実行

## 5. テスト設計

### 5.1 単体テスト設計
各コンポーネントの単体テストは `tests/unit/` 配下に配置され、以下のアプローチで実装されています。

- **依存性注入**: 外部依存はモックに置換可能
- **インターフェース抽象化**: 実装の詳細に依存しないテスト
- **単一責任**: 各クラスは単一の責任を持ち、テスト容易性を確保

### 5.2 結合テスト設計
`tests/integration/` 配下には、複数コンポーネントの連携を検証するテストが実装されています。

- フェイクデバイス実装によるハードウェア不要のテスト
- エンドツーエンドでのマクロ実行フローテスト
- 例外発生時のエラーハンドリングテスト

## 6. 将来の拡張性

### 6.1 手動入力層の追加
将来的に、PC接続のコントローラーやキーボードからの手動入力をサポートする拡張が計画されています。

- 入力取得・イベント処理は専用モジュールで実装
- 既存の自動操作層とは異なるフローで処理
- 共通の送信部分は再利用し、モード切替機能で連携

### 6.2 マクロ実行の拡張
以下の機能拡張が検討されています。

- **マクロの中断・再開機能**:
  `CancellationToken` の拡張で実装予定

- **複数マクロの同時実行**:
  並列処理モデルの導入で対応予定

- **詳細なエラーハンドリング**:
  例外の階層化と回復メカニズムの強化

### 6.3 プロトコル拡張
新たなデバイスへの対応は、`SerialProtocolInterface` の新規実装で容易に追加可能です。

## 7. 参考資料

- [ハードウェア連携設計詳細](./hardware_design.md)
- [マクロフレームワーク設計詳細](./macro_design.md)
- [通信プロトコル設計詳細](./protocol_design.md)
- [CH552Protocol仕様書](./protocol/ch552_protocol_spec.md)
- [ログ管理設計詳細](./logging_design.md)

## 追加: GUIアーキテクチャの要点

### DeviceModel/EventBus/シングルトン設計
- Manager系（SerialManager, CaptureManager, SettingsService）は`singletons.py`で一元管理
- DeviceModelがアクティブデバイスの切替・参照・イベント発行を担当
- GUIコンポーネントやコマンドはDeviceModel/Managerからデバイスを受け取り、直接操作
- 状態変更はEventBusで伝播し、疎結合な設計を実現
