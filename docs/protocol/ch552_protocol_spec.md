# CH552 Serial Protocol 仕様書

本仕様書は、CH552 デバイス向けのシリアル通信プロトコル（CH552SerialProtocol）について記述します。  
このプロトコルは、Nintendo Switch の自動化支援のために、各種キー操作やスティック入力、キーボード入力を  
バイナリデータに変換して送信するためのものです。

---

## 1. プロトコルフレーム構造

CH552SerialProtocol のデータフレームは、全体で **11バイト** で構成され、各フィールドは以下の通りです。

| バイト番号 | フィールド名    | 説明                                                           | 初期値/デフォルト         |
|------------|----------------|----------------------------------------------------------------|---------------------------|
| 0          | header         | 固定値。プロトコル開始を示す。                                 | `0xAB`                   |
| 1          | btn1           | ボタン操作の下位8ビット。各 Button 値の下位バイトの OR 演算結果。 | `0x00`                   |
| 2          | btn2           | ボタン操作の上位8ビット。各 Button 値の上位バイトの OR 演算結果。 | `0x00`                   |
| 3          | hat            | 方向パッドの状態。押下時は該当する値、解放時は `Hat.CENTER`。   | `Hat.CENTER` (例: 0x08)   |
| 4          | lx             | 左スティックの X 座標。中央位置は `0x80`。                     | `0x80`                   |
| 5          | ly             | 左スティックの Y 座標。中央位置は `0x80`。                     | `0x80`                   |
| 6          | rx             | 右スティックの X 座標。中央位置は `0x80`。                     | `0x80`                   |
| 7          | ry             | 右スティックの Y 座標。中央位置は `0x80`。                     | `0x80`                   |
| 8          | kbdheader      | キーボード操作種別フラグ。下記参照。                         | `0x00`                   |
| 9          | key            | キーボード入力用のキー情報（ASCIIコード等）。                | `0x00`                   |
| 10         | centinel       | 予備（未使用、常に0）。                                    | `0x00`                   |

#### kbdheader（バイト8）の値と意味

| 値 | 意味                |
|----|---------------------|
| 0  | キーボード操作なし   |
| 1  | 通常キー押下        |
| 2  | 通常キーリリース    |
| 3  | 特殊キー押下        |
| 4  | 特殊キーリリース    |
| 5  | 全キーリリース      |

#### key （バイト9）

- 押下/リリースするキーのASCIIコードまたは特殊キーコード

#### centinel（バイト10）

- 未使用（常に0）

---

## 2. 操作ごとの動作

### 2.1 ボタン操作 (Button)

CH552SerialProtocol では、以下のボタンが `Button` クラスの定義に基づいて扱われます。

| ボタン名 | 値 (`Button` クラス) |
|----------|---------------------|
| Y        | `0x0001`            |
| B        | `0x0002`            |
| A        | `0x0004`            |
| X        | `0x0008`            |
| L        | `0x0010`            |
| R        | `0x0020`            |
| ZL       | `0x0040`            |
| ZR       | `0x0080`            |
| MINUS    | `0x0100`            |
| PLUS     | `0x0200`            |
| LS (Lスティック押下) | `0x0400` |
| RS (Rスティック押下) | `0x0800` |
| HOME     | `0x1000`            |
| CAPTURE  | `0x2000`            |

#### **押下 (hold)**
1. `btn1` フィールド（下位8ビット）に対して `Button` 値の **下位バイト** を OR 演算で追加
2. `btn2` フィールド（上位8ビット）に対して `Button` 値の **上位バイト** を OR 演算で追加

#### **解放 (release)**
1. `btn1` フィールドから対象ボタン(`Button`)の **下位バイト** をクリア（AND NOT 演算）
2. `btn2` フィールドから対象ボタン(`Button`)の **上位バイト** をクリア（AND NOT 演算）

---

### 2.2 方向パッド操作 (Hat)

方向パッド (`Hat`) は以下のように定義されています。

| 方向 | `Hat` クラスの値 |
|------|----------------|
| UP   | `0x00`         |
| UPRIGHT | `0x01`     |
| RIGHT  | `0x02`       |
| DOWNRIGHT | `0x03`   |
| DOWN  | `0x04`       |
| DOWNLEFT | `0x05`    |
| LEFT  | `0x06`       |
| UPLEFT | `0x07`      |
| CENTER | `0x08` (ニュートラル) |

#### **押下**
- `hat` フィールドを、対応する `Hat` の値で上書き

#### **解放**
- `hat` フィールドを `Hat.CENTER (0x08)` にリセット

---

### 2.3 スティック操作 (LStick, RStick)

スティック (`LStick`, `RStick`) は、それぞれX軸（左右）とY軸（上下）の座標値を持ちます。  
これらの座標は、**スティックの角度**（方向）と **入力の強さ**（倒し具合）によって決定されます。

#### **スティック座標の範囲**
| 方向      | X 軸 (`lx`, `rx`) | Y 軸 (`ly`, `ry`) |
|-----------|-----------------|-----------------|
| **左**    | 最小 (`0x00`)    | - |
| **右**    | 最大 (`0xFF`)    | - |
| **上**    | -               | 最小 (`0x00`) |
| **下**    | -               | 最大 (`0xFF`) |
| **中央**  | `0x80`（中立）  | `0x80`（中立） |

- **X 軸 (`lx`, `rx`)**
  - `0x00` に近いほど **左方向**
  - `0xFF` に近いほど **右方向**
  - `0x80` は **中央（ニュートラル）**
  
- **Y 軸 (`ly`, `ry`)**
  - `0x00` に近いほど **上方向**
  - `0xFF` に近いほど **下方向**
  - `0x80` は **中央（ニュートラル）**

#### **押下時**
- 指定されたスティックの角度と強さに応じて `lx, ly`（または `rx, ry`）の値を計算
- 例：
  - `LStick.UP` を指定すると `ly` が `0x00`（最小値）になり、上方向に最大倒し
  - `RStick.DOWNRIGHT` を指定すると `rx` が `0xFF`（最大値）、`ry` が `0xFF`（最大値）になり、右下方向に最大倒し

#### **解放時**
- スティックを中央 (`LStick.CENTER` / `RStick.CENTER`) にリセット
  - `lx, ly = 0x80`
  - `rx, ry = 0x80`

---

### 2.4 キーボード入力

キーボードの入力は `kbdheader`, `key1` の2つのフィールドで管理されます。

#### **build_keyboard_command**
- `kbdheader`: `0x01` （キーボード入力の開始フラグ）
- `key1`: 入力するキーの ASCII コード（または適宜変換した値）

---

## 3. コマンド生成の例

### 3.1 press コマンド例
- **操作:** Button A と Button B の同時押下、Hat を UP に、左スティックを (x=100, y=150) に設定  
- **生成されるフレーム:**  
`[0xAB, btn1, btn2, UP, 100, 150, 0x80, 0x80, 0x00, 0x00, 0x00]` 
※btn1, btn2 は、Button A, B の値に応じた OR 演算結果

### 3.2 release コマンド例
- **操作:** Button A の解放、左スティックを中央にリセット  
- **生成されるフレーム:**  
`[0xAB, (btn1からAがクリアされた値), (btn2からAがクリアされた値), CENTER, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00]`

---

## 4. 注意点

- **内部状態:**  
CH552SerialProtocol は内部状態（key_state）を持ち、連続した操作で状態が変化します。  
release 操作でキーが指定されない場合は、全体が初期状態にリセットされます。